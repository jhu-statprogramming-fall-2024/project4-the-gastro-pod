<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lulu Singer, Jill Hakim, Jack Zhu">

<title>Snashboard Final Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Snashboard_Final_Report_files/libs/clipboard/clipboard.min.js"></script>
<script src="Snashboard_Final_Report_files/libs/quarto-html/quarto.js"></script>
<script src="Snashboard_Final_Report_files/libs/quarto-html/popper.min.js"></script>
<script src="Snashboard_Final_Report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Snashboard_Final_Report_files/libs/quarto-html/anchor.min.js"></script>
<link href="Snashboard_Final_Report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Snashboard_Final_Report_files/libs/quarto-html/quarto-syntax-highlighting-3a01e2046221230fdceeea94b1ec5d67.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Snashboard_Final_Report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Snashboard_Final_Report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Snashboard_Final_Report_files/libs/bootstrap/bootstrap-9b365665436b74601bfdd373904bad7c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Snashboard Final Report</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lulu Singer, Jill Hakim, Jack Zhu </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="snashboard-a-snail-dashboard-project" class="level2">
<h2 class="anchored" data-anchor-id="snashboard-a-snail-dashboard-project"><strong>SNASHBOARD: A Snail Dashboard Project</strong> &nbsp;</h2>
<p><strong>Jill Hakim</strong> (jhakim2@jhmi.edu)<strong>, Lulu Singer</strong> (lsinger9@jhmi.edu)<strong>, Jack Zhu</strong> (jzhu117@jh.edu)</p>
</section>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>Snashboard is an interactive data visualization tool that combines citizen science research grade observations with geolocation of discovered gastropod fossils. &nbsp;</p>
<p>The goal of this project was primarily to present a large and robust dataset in a user friendly and fun way. Citizen science provides a massive advantage to researchers, generating large and comprehensive datasets that would be prohibitively costly to generate with conventional methods. iNaturalist, an&nbsp;image recognition cell phone app built and maintained by California Academy of Science, is a popular tool used to identify flora and fauna.&nbsp;Thousands of images have been uploaded, and hundreds of publications have made use of these observations. While species identification provides immediate benefit to citizen scientists using the iNaturalist app, there has heretofore not been a way for these users to make use of these observations as a dataset. &nbsp;</p>
<p>In addition to knowledge of extant snail species, an inquisitive user may be equally interested in the&nbsp;paleontological history of snail species in their area. As such, we have supplemented the iNaturalist data with observations generated from the Paleobiology database, an online resource of fossil discoveries. As of writing, there are no current applications that combine extinct and extant gastropod data.&nbsp;&nbsp;</p>
<p>Several summary graphs and statistics are generated, as are maps with tooltip enabled to provide geolocations, and functionality to see the actual uploaded species observation. To emphasize the connectivity between the user and their neighborhood snails, we have enabled a retrieval of images for each snail within the requested location.&nbsp;</p>
<p><img src="images/snashboard.png" class="img-fluid"></p>
<p><strong>Figure 1:</strong> Screenshot of Snashboard, with images of selected snails</p>
<p><img src="images/inat.png" class="img-fluid"></p>
<p><strong>Figure 2:</strong> iNaturalist species observations over time in the Atacama region demonstrating a possible population takeover of Ecginolitorina peruviana, though perhaps not deleteriously at the expense of other snail taxa</p>
<p><img src="images/atacama.png" class="img-fluid"></p>
<p><strong>Figure 3:</strong> Fossil observations within the Atacama region in Chile, colored by the&nbsp;earliest possible year in million years ago the sample may have originated. Inclusion of coast shapefile makes it easy to infer oceanic snail fossils further inland may be a result of shifting coastline.&nbsp;</p>
<p><img src="images/intervals.png" class="img-fluid"></p>
<p><strong>Figure 4:</strong> Geological intervals during which&nbsp;gastropod fossils were found in the Atacama region. The orders Architeanioglosa seems to have co-existed with many other snails in the Pilenscbachian interval approximately 170 mya, though were unable to persist for longer, unlike other orders such as Heterostropha, suggesting that they were specialized to survival during that geological period.</p>
</section>
<section id="research-question" class="level2">
<h2 class="anchored" data-anchor-id="research-question"><strong>Research Question</strong>&nbsp;</h2>
<p>Our inspiration for this project was to investigate the following umbrella question:&nbsp;&nbsp;</p>
<p>What snails are near me?&nbsp;&nbsp;</p>
<p>However, this overarching question can be broken down as follows:&nbsp;&nbsp;</p>
<ol type="1">
<li>Are there ecologically or clinically significant snails where I live?&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>What gastropod species are local to my area?&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="3" type="1">
<li>How do extant gastropod taxa compare to extinct or ancient taxa? &nbsp;</li>
</ol>
<!-- -->
<ol start="4" type="1">
<li>What geologic time periods are local snail fossils from? &nbsp;</li>
</ol>
</section>
<section id="introduction-and-importance" class="level2">
<h2 class="anchored" data-anchor-id="introduction-and-importance">Introduction and Importance &nbsp;</h2>
<p>Tracking the geographic location of snails is important because snails are vital part of local ecosystem but are sensitive to changes in their environment. Snail diversity is decreasing, and some snails may be migrating north due to environmental factors, such as climate change. Snail migration may impact local ecosystems that they were a part of and or ecosystems to which they are migrating. Thus, it is critical for ecologists and conservationists to note diminishing snail populations and factors that may be correlated with such population declines (Hemming, 2023).&nbsp;&nbsp;</p>
<p>Some snails, such as the giant land snail are invasive species, vectors for infectious disease, and have become widespread due to the popularity of exotic pets (Gippet, Bates, Moulin, &amp; Bertelsmeier, 2023).&nbsp;</p>
<p>In previous work, field samples have been collected to study the habitats and migrations of snails, and it would be helpful to have a static or dynamic data product to display where snail varieties are found. Individuals, such as Thomas Evereston on iNaturalist, created a search tool for freshwater and land snails where users can search for and identify snails and other gastropods of interest as well as note when they spot specific species. However, the search tools for freshwater and land snails are separate from each other (Everest, 2023), and do not feature fossil record data for snails once living in the area.&nbsp;&nbsp;</p>
</section>
<section id="research-paradigms" class="level2">
<h2 class="anchored" data-anchor-id="research-paradigms">Research Paradigms &nbsp;</h2>
<p>We wanted to explore the following paradigms:&nbsp;&nbsp;</p>
<ol type="1">
<li>Retrieving data from APIs&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>Working with spatial data&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="3" type="1">
<li>Dashboard programming&nbsp;&nbsp;</li>
</ol>
</section>
<section id="retrieving-data-from-apis-and-working-with-spatial-data" class="level2">
<h2 class="anchored" data-anchor-id="retrieving-data-from-apis-and-working-with-spatial-data"><strong>Retrieving data from APIs&nbsp;and Working with Spatial Data</strong> &nbsp;</h2>
<p><strong>iNaturalist Database</strong> &nbsp;</p>
<p>For our Snashboard Dashboard, we obtained data from the OpenStreetMap API from the osmdata R package, iNaturalist API through the rinat R package, the Paleobiology Database (PBDB) API through the paleoDB R package, and data from the GBIF API using httr and jsonlite R packages. &nbsp;</p>
<p>We utilized the osmdata package to retrieve spatial data from OpenStreetMap (OSM) using the <strong>getbb()</strong> function. The <strong>getbb()</strong> function retrieves the longitude and latitude bounds for the location that the user of the dashboard specifies.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>bb <span class="ot">&lt;-</span> <span class="fu">eventReactive</span>(input<span class="sc">$</span>enter, {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">req</span>(input<span class="sc">$</span>location)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">getbb</span>(input<span class="sc">$</span>location)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <strong>opq(bbox = bb())</strong> function creates an API query for the bounding box. The <strong>add_osm_feature</strong> function in <strong>add_osm_feature(key = ‘boundary’, value = “administrative”) (key = ‘boundary’, value = “administrative”)</strong> filters the query by administrative features, such as city and or state. The <strong>osmdata_sf()</strong> functionfetches the data queried and returns it as an sf, or spatial features object. &nbsp;</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>map_feat <span class="ot">&lt;-</span> <span class="fu">eventReactive</span>(input<span class="sc">$</span>enter, {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">opq</span>(<span class="at">bbox =</span> <span class="fu">bb</span>()) <span class="sc">%&gt;%</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">add_osm_feature</span>(<span class="at">key =</span> <span class="st">'boundary'</span>, <span class="at">value =</span> <span class="st">"administrative"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">osmdata_sf</span>()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>iNaturalist data points are rendered over the administrative bounds, and the <strong>geom_sf()</strong> function in <strong>geom_sf(data = map_feat()$osm_lines)</strong> is utilized to add spatial lines to the administrative bounds. &nbsp;</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>output<span class="sc">$</span>inat_map <span class="ot">&lt;-</span> <span class="fu">renderPlotly</span>({</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">nrow</span>(<span class="fu">inat_data</span>()) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        p <span class="ot">&lt;-</span> <span class="fu">inat_data</span>() <span class="sc">%&gt;%</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x =</span> longitude, <span class="at">y =</span> latitude, <span class="at">color =</span> scientific_name), <span class="at">show.legend =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_sf</span>(<span class="at">data =</span> <span class="fu">map_feat</span>()<span class="sc">$</span>osm_lines) <span class="sc">+</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="fu">xlim</span>(<span class="fu">bb</span>()[<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)]) <span class="sc">+</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ylim</span>(<span class="fu">bb</span>()[<span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">4</span>)]) <span class="sc">+</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ggplotly</span>(p, <span class="at">source =</span> <span class="st">"inat_map"</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        no_data_p</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <strong>rinat</strong> package is utilized to fetch data from iNaturalist. The <strong>get_inat_obs()</strong> function retrieves observations from the iNaturalist data set and limits the search to organisms with the taxon name, “Gastropoda,” which includes snails. The <strong>bounds=bounds</strong> statement defines the area for the query utilizing the coordinates retrieved from the osmdata package. The <strong>quality = “research”</strong> statement filters the query for research-grade observations, only, and the <strong>maxresults=10000</strong> statement limits the search results count to 10,000 results. Most&nbsp;region-level locations (i.e.&nbsp;city, county, region, etc.) will have fewer than 1000 results, but this prevents accidental “rude” querying if a user attempts to query a large state or entire country. For reference, Baltimore, MD returns 254 results, and the entire state of Maryland returns 9,256 results.&nbsp;</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>inat_data <span class="ot">&lt;-</span> <span class="fu">eventReactive</span>(input<span class="sc">$</span>enter, {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    bounds <span class="ot">&lt;-</span> <span class="fu">bb</span>()[<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>)]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">get_inat_obs</span>(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">taxon_name =</span> <span class="st">"Gastropoda"</span>, </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">bounds =</span> bounds, </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">quality =</span> <span class="st">"research"</span>, </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">maxresults =</span> <span class="dv">10000</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When the iNaturalist data is fetched from the iNaturalist API, it is stored in the inat_data data frame, which also contains the image URLs corresponding to the observations. &nbsp;</p>
<p>The iNaturalist data is plotted on a map with the bounds of the user-specified location through the Plotly object output$inat_map. When the user clicks on a point of the map, the information about the click event is captured by Plotly’s event_data() function. The pointNumber index is adjusted by 1 since Plotly uses zero-based indexing while R uses one-based indexing. The clicked point is then matched with its corresponding row in the inat_data data frame. The corresponding image URL is extracted from the image_url column of inat_data(), if available. If a valid URL is available for the image corresponding to the clicked iNaturalist observation, an image will be generated. If not, the message “No image available for this observation” will appear. &nbsp;</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Render the iNaturalist image with slider input</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    output<span class="sc">$</span>clicked_image <span class="ot">&lt;-</span> <span class="fu">renderUI</span>({</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      point_data_inat <span class="ot">&lt;-</span> <span class="fu">event_data</span>(<span class="st">"plotly_click"</span>, <span class="at">source =</span> <span class="st">"inat_map"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">req</span>(point_data_inat)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      point_id_inat <span class="ot">&lt;-</span> point_data_inat<span class="sc">$</span>pointNumber <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      img_url_inat <span class="ot">&lt;-</span> <span class="fu">inat_data</span>()<span class="sc">$</span>image_url[point_id_inat]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>      img_size_inat <span class="ot">&lt;-</span> <span class="fu">paste0</span>(input<span class="sc">$</span>image_size, <span class="st">"px"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(img_url_inat) <span class="sc">&amp;&amp;</span> <span class="fu">nzchar</span>(img_url_inat)) {</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        tags<span class="sc">$</span><span class="fu">img</span>(</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>          <span class="at">src =</span> img_url_inat, </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>          <span class="at">alt =</span> <span class="st">"Observation Image"</span>, </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>          <span class="at">style =</span> <span class="fu">paste</span>(<span class="st">"width:"</span>, img_size_inat, <span class="st">"; height:"</span>, img_size_inat, <span class="st">"; object-fit: contain; border: 1px solid black;"</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        tags<span class="sc">$</span><span class="fu">p</span>(<span class="st">"No image available for this observation."</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    })</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Paleobiology Database (PBDB)</strong>&nbsp;</p>
<p>We utilized the paleobioDB package and pbdb_occurences() function to query Gastropoda fossil occurrence data from the Paleobiology Database (PBDB) during the Late Cretaceous Period (65 to 100 million years ago) in&nbsp;specific geographical areas in the United States. The query results are loaded into the reactive data frame pbdb_data, which is used for map and graph visualizations for the “Snails that were near you” section of the Snashboard Dashboard. &nbsp;</p>
<p>On the Paleobiology Database side, the visualizations include the following: &nbsp;</p>
<p><strong>Explore Tab</strong>&nbsp;</p>
<ol type="1">
<li>A map of fossil occurrences within the coordinate bounds of the location (city, state, etc.) that the user searches for in the dashboard&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>An Eras Bars bar chart that displays the geologic eras by taxonomic order of the fossils found &nbsp;</li>
</ol>
<p><strong>Taxa Tab</strong> &nbsp;</p>
<ol type="1">
<li>An abundance bar chart and data table that shows the frequency of genera of snails found within the location that the user is searching for &nbsp;</li>
</ol>
<p><strong>All Observations Tab</strong>&nbsp;</p>
<ol type="1">
<li>A data table of all the fossil observations within the geographic bounds of a user inputted location is shown &nbsp;</li>
</ol>
<p><strong>Global Diversity&nbsp;Information Facility (GBIF) API</strong> &nbsp;</p>
<p>ThePaleobiology Database (PBDB) did not have fossil specimen images, so we pulled the corresponding images to fossil observations through the Global Diversity Information Facility (GBIF) API with the httr and jsonlite packages, which handle the API request and parses the JSON response from the API, respectively. &nbsp;</p>
<p>In the function, get_gbif_image, an API is constructed with the API endpoint URL. The URL string is passed through to httr::GET, which sends a request to the endpoint. After receiving a response, the JSON content is parsed into a list. &nbsp;</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to Fetch GBIF Image</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>get_gbif_image <span class="ot">&lt;-</span> <span class="cf">function</span>(taxon_name) {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"https://api.gbif.org/v1/occurrence/search?mediaType=StillImage&amp;scientificName="</span>, <span class="fu">URLencode</span>(taxon_name))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> httr<span class="sc">::</span><span class="fu">GET</span>(url)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (res<span class="sc">$</span>status_code <span class="sc">==</span> <span class="dv">200</span>) {</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">&lt;-</span> jsonlite<span class="sc">::</span><span class="fu">fromJSON</span>(<span class="fu">content</span>(res, <span class="st">"text"</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(data<span class="sc">$</span>results) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(data<span class="sc">$</span>results) <span class="sc">&gt;</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> <span class="sc">!</span><span class="fu">is.null</span>(data<span class="sc">$</span>results<span class="sc">$</span>media[[<span class="dv">1</span>]])) {</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>      img_url <span class="ot">&lt;-</span> data<span class="sc">$</span>results<span class="sc">$</span>media[[<span class="dv">1</span>]]<span class="sc">$</span>identifier[<span class="dv">1</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(img_url)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The render function in the Shiny UI, <strong>output$clicked_pbdb</strong> image captures a click event from the PBDB map through the reactive variable, <strong>point_data_pbdb</strong>. When a click event is confirmed, the point index of the plotly click is adjusted to one-based indexing (Plotly uses zero-based indexing) so that the corresponding genus name is extracted. Afterwards, the <strong>get_gbif_image()</strong> function is called with <strong>genus_name_pbdb</strong>, which is the argument that contains the genus name of the fossil record that the user clicked on in the PBDB map. Within the function, a GET request is sent to the GBIF API, and a query is conducted for occurrences of the genus with images.If an image is available, the corresponding image is displayed. Otherwise, the message, <strong>“No image available for genus,”</strong> appears. &nbsp;</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>output<span class="sc">$</span>clicked_pbdb_image <span class="ot">&lt;-</span> <span class="fu">renderUI</span>({</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  point_data_pbdb <span class="ot">&lt;-</span> <span class="fu">event_data</span>(<span class="st">"plotly_click"</span>, <span class="at">source =</span> <span class="st">"pbdb_map"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">req</span>(point_data_pbdb)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  point_id_pbdb <span class="ot">&lt;-</span> point_data_pbdb<span class="sc">$</span>pointNumber <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  genus_name_pbdb <span class="ot">&lt;-</span> <span class="fu">pbdb_data</span>()<span class="sc">$</span>genus[point_id_pbdb]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  img_url_pbdb <span class="ot">&lt;-</span> <span class="fu">get_gbif_image</span>(genus_name_pbdb)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  img_size_pbdb <span class="ot">&lt;-</span> <span class="fu">paste0</span>(input<span class="sc">$</span>image_size, <span class="st">"px"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(img_url_pbdb) <span class="sc">&amp;&amp;</span> <span class="fu">nzchar</span>(img_url_pbdb)) {</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    tags<span class="sc">$</span><span class="fu">img</span>(</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">src =</span> img_url_pbdb, </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">alt =</span> <span class="fu">paste</span>(<span class="st">"Fossil image of"</span>, genus_name_pbdb), </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">style =</span> <span class="fu">paste</span>(<span class="st">"width:"</span>, img_size_pbdb, <span class="st">"; height:"</span>, img_size_pbdb, <span class="st">"; object-fit: contain; border: 1px solid black;"</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    tags<span class="sc">$</span><span class="fu">div</span>(</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>      <span class="at">style =</span> <span class="st">"padding: 20px; border: 1px solid black; background-color: #f9f9f9;"</span>,</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>      tags<span class="sc">$</span><span class="fu">p</span>(</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="at">style =</span> <span class="st">"font-size: 16px; font-weight: bold; color: #333;"</span>,</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="fu">paste</span>(<span class="st">"No image available for genus:"</span>, genus_name_pbdb)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="dashboard-programming" class="level2">
<h2 class="anchored" data-anchor-id="dashboard-programming"><strong>Dashboard Programming</strong>&nbsp;</h2>
<p>The <strong>output$inat_map</strong> outputs an interactive map with the <strong>plotly</strong> and <strong>ggplot2</strong> packages. The interactive map shows snail observations from the iNaturalist database within the administrative bounds of the location the user enters in the dashboard. The records observed are filtered by user-defined years indicated by the slider input. &nbsp;</p>
<p>We also included a download button in the user interface:&nbsp;</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding the download button inside the sidebar so that users can download csv of data</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">downloadButton</span>(<span class="st">"download_combined"</span>, <span class="st">"Download Data (CSV)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The download options are handled by the <strong>downloadHandler()</strong> function in the server block of the Shiny application. Users are able to download iNaturalist or Paleobiology database data for their input location with select columns of their choice as a CSV file. The file name of the data set is the data source_date. For example, if an iNaturalist table was downloaded on December 19th, the file name would be “inat_data_2024-12-19.csv”. &nbsp;</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>output<span class="sc">$</span>download_combined <span class="ot">&lt;-</span> <span class="fu">downloadHandler</span>(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>      <span class="at">filename =</span> <span class="cf">function</span>() {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">paste0</span>(input<span class="sc">$</span>data_source, <span class="st">"_data_"</span>, <span class="fu">Sys.Date</span>(), <span class="st">".csv"</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      },</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>      <span class="at">content =</span> <span class="cf">function</span>(file) {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">req</span>(input<span class="sc">$</span>data_source, input<span class="sc">$</span>selected_columns)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Select the appropriate dataset</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        data_to_download <span class="ot">&lt;-</span> <span class="cf">if</span> (input<span class="sc">$</span>data_source <span class="sc">==</span> <span class="st">"inat"</span>) {</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>          <span class="fu">inat_data</span>()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pbdb_data</span>()</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if any columns are selected</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">length</span>(input<span class="sc">$</span>selected_columns) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>          <span class="fu">showNotification</span>(<span class="st">"Please select at least one column to download."</span>, <span class="at">type =</span> <span class="st">"error"</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Export only selected columns</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">write.csv</span>(</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>          data_to_download[, input<span class="sc">$</span>selected_columns, <span class="at">drop =</span> <span class="cn">FALSE</span>], </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>          file, </span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>          <span class="at">row.names =</span> <span class="cn">FALSE</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="limitations-and-future-directions" class="level2">
<h2 class="anchored" data-anchor-id="limitations-and-future-directions"><strong>Limitations and Future Directions</strong> &nbsp;</h2>
<p>One limitation of our Snashboard database is that the distribution of paleobiology data is dependent on (1) paleontological research and (2) geologic conditions that favored fossilization. As a result, there may be data gaps in areas where there is not likely to be fossils identified, either due to a&nbsp;lack of interest by paleontologists, fewer sedentary deposits, or a lack of access to such deposits (ex. urban areas). For example, paleobiology data for Baltimore is not available on this dashboard. &nbsp;</p>
<p>Another limitation of our Snashboard database is that the extant snail data we utilized comes from an iNaturalist, a citizen science database, meaning that data is collected through members of the public. The richness of the data obtained for any location partially depends on how densely populated the location and whether members of the public are interested in studying snails. &nbsp;</p>
<p>Lastly, the Paleobiology Database does not have natively provide images of fossils or specimens, so we had to pull the images from the Global Biodiversity Information Facility (GBIF) database, a data repository providing open-source data about life on earth, and matched them by genus. &nbsp;</p>
<p>In the future, we would like to include a way to combine both the iNaturalist and Paleobiology datasets. One feature we would like to add is a way to analyze the phylogeny of the extinct and extact taxa in the area (such as with an interactive phylogenic tree). Additionally, we would like to add phylogeny comparisons between eras in the Paledataset.</p>
<p>We would have loved to incorporate climate data to the observation tables so that a user could compare the climate that particular present and past snails thrived in. However, we would have had to incorporate multiple data sources since there isn’t a “consensus” climate database for paleoclimate data. Rather, multiple climate models have been made for different eras/spans of eras that make it difficult to just pull that data.&nbsp;</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references"><strong>References</strong></h2>
<ol type="1">
<li>About · inaturalist. iNaturalist. (n.d.). <a href="https://www.inaturalist.org/pages/about" class="uri">https://www.inaturalist.org/pages/about</a> &nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>Brant, S. V., Bochte, C. A., &amp; Loker, E. S. (2011). New intermediate host records for the avian schistosomes Dendritobilharzia pulverulenta, Gigantobilharzia huronensis, and Trichobilharzia querquedulae from North America. Journal of Parasitology, 97(5), 946–949. <a href="https://doi.org/10.1645/ge-2743.1" class="uri">https://doi.org/10.1645/ge-2743.1</a> &nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="3" type="1">
<li><strong>Cornu aspersum (brown garden snail),</strong> Centre for Agriculture and Biosciences International. <a href="https://www.cabidigitallibrary.org/doi/10.1079/cabicompendium.26821" class="uri">https://www.cabidigitallibrary.org/doi/10.1079/cabicompendium.26821</a>&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="4" type="1">
<li><strong>Euglandina rosea (rosy predator snail),</strong> Centre for Agriculture and Biosciences International. <a href="https://www.cabidigitallibrary.org/doi/10.1079/cabicompendium.23113" class="uri">https://www.cabidigitallibrary.org/doi/10.1079/cabicompendium.23113</a>&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="5" type="1">
<li>Everest, T. (2023, March 31). Search tools for mollusks by habitat. iNaturalist. <a href="https://www.inaturalist.org/journal/thomaseverest/77252-search-tools-for-mollusks-by-habitat" class="uri">https://www.inaturalist.org/journal/thomaseverest/77252-search-tools-for-mollusks-by-habitat</a>&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="6" type="1">
<li>Gippet, J.M.W., Bates, O.K., Moulin, J. et al.&nbsp;The global risk of infectious disease emergence from giant land snail invasion and pet trade. Parasites Vectors <strong>16</strong>, 363 (2023). <a href="https://doi.org/10.1186/s13071-023-06000-y" class="uri">https://doi.org/10.1186/s13071-023-06000-y</a>&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="7" type="1">
<li>What is Gbif?. GBIF. (n.d.). <a href="https://www.gbif.org/what-is-gbif" class="uri">https://www.gbif.org/what-is-gbif</a>&nbsp;</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>